import { maybeAuditArgumentChecks } from "./common.js";

// Constructor for a sub handle: the input to each publish function

// Instance name is this because it's usually referred to as this inside a
// publish
/**
 * @summary The server's side of a subscription
 * @class Subscription
 * @instanceName this
 * @showInstanceName true
 */
export default class Subscription {
  constructor(session, handler, subscriptionId, params, name, allowBuffering) {
    var self = this;
    self._session = session; // type is Session

    /**
     * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.
     * @locus Server
     * @name  connection
     * @memberOf Subscription
     * @instance
     */
    self.connection = session.connectionHandle; // public API object

    self._handler = handler;

    // my subscription ID (generated by client, undefined for universal subs).
    self._subscriptionId = subscriptionId;
    // undefined for universal subs
    self._name = name;

    self._params = params || [];

    // Only named subscriptions have IDs, but we need some sort of string
    // internally to keep track of all subscriptions inside
    // SessionDocumentViews. We use this subscriptionHandle for that.
    if (self._subscriptionId) {
      self._subscriptionHandle = 'N' + self._subscriptionId;
    } else {
      self._subscriptionHandle = 'U' + Random.id();
    }

    // has _deactivate been called?
    self._deactivated = false;

    // stop callbacks to g/c this sub.  called w/ zero arguments.
    self._stopCallbacks = [];

    // remember if we are ready.
    self._ready = false;

    // Part of the public API: the user of this sub.

    /**
     * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.
     * @locus Server
     * @memberOf Subscription
     * @name  userId
     * @instance
     */
    self.userId = session.userId;

    // allow bufferings of changes to the collections in this publication
    self.allowBuffering = allowBuffering || false;

    Package.facts && Package.facts.Facts.incrementServerFact(
      "livedata", "subscriptions", 1);
  }

  _runHandler() {
    // XXX should we unblock() here? Either before running the publish
    // function, or before running _publishCursor.
    //
    // Right now, each publish function blocks all future publishes and
    // methods waiting on data from Mongo (or whatever else the function
    // blocks on). This probably slows page load in common cases.

    var self = this;
    try {
      var res = DDP._CurrentPublicationInvocation.withValue(
        self,
        () => maybeAuditArgumentChecks(
          self._handler, self, EJSON.clone(self._params),
          // It's OK that this would look weird for universal subscriptions,
          // because they have no arguments so there can never be an
          // audit-argument-checks failure.
          "publisher '" + self._name + "'"
        )
      );
    } catch (e) {
      self.error(e);
      return;
    }

    // Did the handler call this.error or this.stop?
    if (self._isDeactivated())
      return;

    self._publishHandlerResult(res);
  }

  _publishHandlerResult(res) {
    // SPECIAL CASE: Instead of writing their own callbacks that invoke
    // this.added/changed/ready/etc, the user can just return a collection
    // cursor or array of cursors from the publish function; we call their
    // _publishCursor method which starts observing the cursor and publishes the
    // results. Note that _publishCursor does NOT call ready().
    //
    // XXX This uses an undocumented interface which only the Mongo cursor
    // interface publishes. Should we make this interface public and encourage
    // users to implement it themselves? Arguably, it's unnecessary; users can
    // already write their own functions like
    //   var publishMyReactiveThingy = function (name, handler) {
    //     Meteor.publish(name, function () {
    //       var reactiveThingy = handler();
    //       reactiveThingy.publishMe();
    //     });
    //   };

    var self = this;
    var isCursor = function (c) {
      return c && c._publishCursor;
    };
    if (isCursor(res)) {
      try {
        res._publishCursor(self);
      } catch (e) {
        self.error(e);
        return;
      }
      // _publishCursor only returns after the initial added callbacks have run.
      // mark subscription as ready.
      self.ready();
    } else if (_.isArray(res)) {
      // check all the elements are cursors
      if (! _.all(res, isCursor)) {
        self.error(new Error("Publish function returned an array of non-Cursors"));
        return;
      }
      // find duplicate collection names
      // XXX we should support overlapping cursors, but that would require the
      // merge box to allow overlap within a subscription
      var collectionNames = {};
      for (var i = 0; i < res.length; ++i) {
        var collectionName = res[i]._getCollectionName();
        if (_.has(collectionNames, collectionName)) {
          self.error(new Error(
            "Publish function returned multiple cursors for collection " +
              collectionName));
          return;
        }
        collectionNames[collectionName] = true;
      };

      try {
        _.each(res, function (cur) {
          cur._publishCursor(self);
        });
      } catch (e) {
        self.error(e);
        return;
      }
      self.ready();
    } else if (res) {
      // truthy values other than cursors or arrays are probably a
      // user mistake (possible returning a Mongo document via, say,
      // `coll.findOne()`).
      self.error(new Error("Publish function can only return a Cursor or "
                          + "an array of Cursors"));
    }
  }

  // This calls all stop callbacks and prevents the handler from updating any
  // SessionCollectionViews further. It's used when the user unsubscribes or
  // disconnects, as well as during setUserId re-runs. It does *NOT* send
  // removed messages for the published objects; if that is necessary, call
  // _removeAllDocuments first.
  _deactivate() {
    var self = this;
    if (self._deactivated)
      return;
    self._deactivated = true;
    self._callStopCallbacks();
    Package.facts && Package.facts.Facts.incrementServerFact(
      "livedata", "subscriptions", -1);
  }

  _callStopCallbacks() {
    var self = this;
    // tell listeners, so they can clean up
    var callbacks = self._stopCallbacks;
    self._stopCallbacks = [];
    _.each(callbacks, function (callback) {
      callback();
    });
  }

  // Send remove messages for every document.
  _removeAllDocuments() {
    var self = this;
    var session = self._session;

    Meteor._noYieldsAllowed(function () {
      _.each(session.collectionViews, function(collectionView, collectionName) {
        _.each(_.keys(collectionView.documents), function(id) {
          self.removed(collectionName, id);
        });
      });
    });
  }

  // Returns a new Subscription for the same session with the same
  // initial creation parameters. This isn't a clone: it doesn't have
  // the same SessionCollectionView, stopped state or callbacks; may have
  // a different _subscriptionHandle, and gets its userId from the
  // session, not from this object.
  _recreate() {
    var self = this;
    return new Subscription(
      self._session, self._handler, self._subscriptionId, self._params,
      self._name, self.allowBuffering);
  }

  /**
   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).
   * @locus Server
   * @param {Error} error The error to pass to the client.
   * @instance
   * @memberOf Subscription
   */
  error(error) {
    var self = this;
    if (self._isDeactivated())
      return;
    self._session._stopSubscription(self._subscriptionId, error);
  }

  // Note that while our DDP client will notice that you've called stop() on the
  // server (and clean up its _subscriptions table) we don't actually provide a
  // mechanism for an app to notice this (the subscribe onError callback only
  // triggers if there is an error).

  /**
   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.
   * @locus Server
   * @instance
   * @memberOf Subscription
   */
  stop() {
    var self = this;
    if (self._isDeactivated())
      return;
    self._session._stopSubscription(self._subscriptionId);
  }

  /**
   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.
   * @locus Server
   * @memberOf Subscription
   * @instance
   * @param {Function} func The callback function
   */
  onStop(callback) {
    var self = this;
    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);
    if (self._isDeactivated())
      callback();
    else
      self._stopCallbacks.push(callback);
  }

  // This returns true if the sub has been deactivated, *OR* if the session was
  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't
  // happened yet.
  _isDeactivated() {
    var self = this;
    return self._deactivated || self._session.inQueue === null;
  }

  messages(collectionName, messages) {
    var self = this;
    if (self._isDeactivated()) {
      return;
    }
    self._session.messages(self._subscriptionHandle, collectionName, messages);
  }

  /**
   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.
   * @locus Server
   * @memberOf Subscription
   * @instance
   * @param {String} collection The name of the collection that contains the new document.
   * @param {String} id The new document's ID.
   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.
   */
  added(collectionName, id, fields) {
    var self = this;
    if (self._isDeactivated()) {
      return;
    }
    self._session.added(self._subscriptionHandle, collectionName, id, fields);
  }

  /**
   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.
   * @locus Server
   * @memberOf Subscription
   * @instance
   * @param {String} collection The name of the collection that contains the changed document.
   * @param {String} id The changed document's ID.
   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.
   */
  changed(collectionName, id, fields) {
    var self = this;
    if (self._isDeactivated()) {
      return;
    }
    self._session.changed(self._subscriptionHandle, collectionName, id, fields);
  }

  /**
   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.
   * @locus Server
   * @memberOf Subscription
   * @instance
   * @param {String} collection The name of the collection that the document has been removed from.
   * @param {String} id The ID of the document that has been removed.
   */
  removed(collectionName, id) {
    var self = this;
    if (self._isDeactivated()) {
      return;
    }
    // We don't bother to delete sets of things in a collection if the
    // collection is empty.  It could break _removeAllDocuments.
    self._session.removed(self._subscriptionHandle, collectionName, id);
  }

  /**
   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.
   * @locus Server
   * @memberOf Subscription
   * @instance
   */
  ready() {
    var self = this;
    if (self._isDeactivated())
      return;
    if (!self._subscriptionId)
      return;  // unnecessary but ignored for universal sub
    if (!self._ready) {
      self._session.sendReady([self._subscriptionId]);
      self._ready = true;
    }
  }
}
